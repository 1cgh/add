Перем РезультатыСравненияТаблиц Экспорт;
Перем СтатусыРезультатаТестирования Экспорт;
Перем ПараметрыОтчетаУФ;
Перем ОтчетВРежимеУФ;
Перем ЭтоLinux;
Перем Регулярка;


Функция ПолучитьВерсиюОбработки(ДобавлятьНазвание = Истина,ТолькоЦифры = Ложь) Экспорт

	Версия = "5.0.0.126";

	Если ТолькоЦифры Тогда
		Возврат Версия;
	КонецЕсли;

	Если ДобавлятьНазвание Тогда
		Возврат "vanessa-behavior ver " + Версия;
	КонецЕсли;

	Возврат "ver " + Версия;
КонецФункции

Функция РазложитьСтрокуВМассивПодстрок(Знач Строка, Знач Разделитель = ",", Знач ПропускатьПустыеСтроки = Неопределено) Экспорт

	Результат = Новый Массив;

	// для обеспечения обратной совместимости
	Если ПропускатьПустыеСтроки = Неопределено Тогда
		ПропускатьПустыеСтроки = ?(Разделитель = " ", Истина, Ложь);
		Если ПустаяСтрока(Строка) Тогда
			Если Разделитель = " " Тогда
				Результат.Добавить("");
			КонецЕсли;
			Возврат Результат;
		КонецЕсли;
	КонецЕсли;

	Позиция = Найти(Строка, Разделитель);
	Пока Позиция > 0 Цикл
		Подстрока = Лев(Строка, Позиция - 1);
		Если Не ПропускатьПустыеСтроки Или Не ПустаяСтрока(Подстрока) Тогда
			Результат.Добавить(Подстрока);
		КонецЕсли;
		Строка = Сред(Строка, Позиция + СтрДлина(Разделитель));
		Позиция = Найти(Строка, Разделитель);
	КонецЦикла;

	Если Не ПропускатьПустыеСтроки Или Не ПустаяСтрока(Строка) Тогда
		Результат.Добавить(Строка);
	КонецЕсли;

	Возврат Результат;

КонецФункции


// { Plugins
// портировано из xUnitFor1C 4.1.1.0

Функция ТипыПлагинов()
	Результат = Новый Структура;
	Результат.Вставить("Загрузчик", "Загрузчик");
	Результат.Вставить("Утилита", "Утилита");
	Результат.Вставить("ГенераторОтчета", "ГенераторОтчета");

	Возврат Новый ФиксированнаяСтруктура(Результат);
КонецФункции

Функция Плагин(Знач Идентификатор) Экспорт

	ИдентификаторПлагинаСПрефиксомПодсистемы = Идентификатор;
	ИдентификаторПлагинаБезПрефиксаПодсистемы = Идентификатор;
	Плагин = Плагины[ИдентификаторПлагинаБезПрефиксаПодсистемы];
	Если ТипЗнч(Плагин) = Тип("Строка") Тогда
		Плагин = СоздатьОбъектПлагина(Плагин);
	КонецЕсли;

	Возврат Плагин;

КонецФункции

Функция ПолучитьОписанияПлагиновПоТипу(Знач ТипПлагина) Экспорт
	Результат = Новый Массив;
	Для каждого КлючЗначение Из Плагины Цикл
		Плагин = Плагин(КлючЗначение.Ключ);
		Плагин.Инициализация(ЭтотОбъект);
		ОписаниеПлагина = Плагин.ОписаниеПлагина(ТипыПлагинов);
		Если ОписаниеПлагина.Тип = ТипПлагина Тогда
			Результат.Добавить(ОписаниеПлагина);
		КонецЕсли;
	КонецЦикла;

	Возврат Результат;
КонецФункции

Функция СоздатьОбъектПлагина(Идентификатор, ВстроенаВКонфигурацию = Ложь, ЭтоОтчет = Ложь) Экспорт

	ОбъектПлагина = Неопределено;

	//Если ЭтотОбъект.ЭтоВстроеннаяОбработка
	//	ИЛИ ВстроенаВКонфигурацию = Истина Тогда
	//
	//	ИдентификаторСПрефиксомПодсистемы = Идентификатор;
	//	ИдентификаторБезПрефиксаПодсистемы = Идентификатор;
	//
	//	Если ЭтоОтчет = Истина Тогда
	//		МенеджерВидаОбъектов = Отчеты;
	//		МетаданныеВидаОбъектов = Метаданные.Отчеты;
	//	Иначе
	//		МенеджерВидаОбъектов = Обработки;
	//		МетаданныеВидаОбъектов = Метаданные.Обработки;
	//	КонецЕсли;
	//
	//	Если НЕ МетаданныеВидаОбъектов.Найти(ИдентификаторСПрефиксомПодсистемы) = Неопределено Тогда
	//		ОбъектПлагина = МенеджерВидаОбъектов[ИдентификаторСПрефиксомПодсистемы].Создать();
	//	ИначеЕсли НЕ МетаданныеВидаОбъектов.Найти(ИдентификаторБезПрефиксаПодсистемы) = Неопределено Тогда
	//		ОбъектПлагина = МенеджерВидаОбъектов[ИдентификаторБезПрефиксаПодсистемы].Создать();
	//	КонецЕсли;
	//
	//КонецЕсли;

	Если ОбъектПлагина = Неопределено Тогда
		Если ЭтоОтчет = Истина Тогда
			ОбъектПлагина = ВнешниеОтчеты.Создать(Идентификатор, Ложь);
		Иначе
			ОбъектПлагина = ВнешниеОбработки.Создать(Идентификатор, Ложь);
		КонецЕсли;
	КонецЕсли;

	Возврат ОбъектПлагина;

КонецФункции

// } Plugins

Функция Транслит(Стр) Экспорт
    Рез = СокрЛП(Стр);
    Рез = СтрЗаменить(Рез,"а","a");
    Рез = СтрЗаменить(Рез,"б","b");
    Рез = СтрЗаменить(Рез,"в","v");
    Рез = СтрЗаменить(Рез,"г","g");
    Рез = СтрЗаменить(Рез,"д","d");
    Рез = СтрЗаменить(Рез,"е","e");
    Рез = СтрЗаменить(Рез,"ё","e");
    Рез = СтрЗаменить(Рез,"ж","zh");
    Рез = СтрЗаменить(Рез,"з","z");
    Рез = СтрЗаменить(Рез,"и","i");
    Рез = СтрЗаменить(Рез,"к","k");
    Рез = СтрЗаменить(Рез,"л","l");
    Рез = СтрЗаменить(Рез,"м","m");
    Рез = СтрЗаменить(Рез,"н","n");
    Рез = СтрЗаменить(Рез,"о","o");
    Рез = СтрЗаменить(Рез,"п","p");
    Рез = СтрЗаменить(Рез,"р","r");
    Рез = СтрЗаменить(Рез,"с","s");
    Рез = СтрЗаменить(Рез,"т","t");
    Рез = СтрЗаменить(Рез,"у","u");
    Рез = СтрЗаменить(Рез,"ф","f");
    Рез = СтрЗаменить(Рез,"х","h");
    Рез = СтрЗаменить(Рез,"ч","ch");
    Рез = СтрЗаменить(Рез,"ш","sh");
    Рез = СтрЗаменить(Рез,"щ","sch");
    Рез = СтрЗаменить(Рез,"ъ","");
    Рез = СтрЗаменить(Рез,"ь","");
    Рез = СтрЗаменить(Рез,"э","e");
    Рез = СтрЗаменить(Рез,"ю","yu");
    Рез = СтрЗаменить(Рез,"й","i");
    Рез = СтрЗаменить(Рез,"ц","c");
    Рез = СтрЗаменить(Рез,"я","ya");
    Рез = СтрЗаменить(Рез,"ы","i");
    Рез = СтрЗаменить(Рез,"А","A");
    Рез = СтрЗаменить(Рез,"Б","B");
    Рез = СтрЗаменить(Рез,"В","V");
    Рез = СтрЗаменить(Рез,"Г","G");
    Рез = СтрЗаменить(Рез,"Д","D");
    Рез = СтрЗаменить(Рез,"Е","E");
    Рез = СтрЗаменить(Рез,"Ё","E");
    Рез = СтрЗаменить(Рез,"Ж","ZH");
    Рез = СтрЗаменить(Рез,"З","Z");
    Рез = СтрЗаменить(Рез,"И","I");
    Рез = СтрЗаменить(Рез,"К","K");
    Рез = СтрЗаменить(Рез,"Л","L");
    Рез = СтрЗаменить(Рез,"М","M");
    Рез = СтрЗаменить(Рез,"Н","N");
    Рез = СтрЗаменить(Рез,"О","O");
    Рез = СтрЗаменить(Рез,"П","P");
    Рез = СтрЗаменить(Рез,"Р","R");
    Рез = СтрЗаменить(Рез,"С","S");
    Рез = СтрЗаменить(Рез,"Т","T");
    Рез = СтрЗаменить(Рез,"У","U");
    Рез = СтрЗаменить(Рез,"Ф","F");
    Рез = СтрЗаменить(Рез,"Х","H");
    Рез = СтрЗаменить(Рез,"Ч","CH");
    Рез = СтрЗаменить(Рез,"Ш","SH");
    Рез = СтрЗаменить(Рез,"Щ","SCH");
    Рез = СтрЗаменить(Рез,"Ъ","");
    Рез = СтрЗаменить(Рез,"Ь","");
    Рез = СтрЗаменить(Рез,"Ы","I");
    Рез = СтрЗаменить(Рез,"Ц","C");
    Рез = СтрЗаменить(Рез,"Э","E");
    Рез = СтрЗаменить(Рез,"Ю","YU");
    Рез = СтрЗаменить(Рез,"Я","YA");
    Рез = СтрЗаменить(Рез,"Й","I");
    Возврат(Рез);
КонецФункции

Процедура СделатьСообщение(Знач Сообщение, ТипСообщения = "Информация") Экспорт

	ТипСообщения = ?(ТипСообщения = "Информация", СтатусСообщения.Обычное, СтатусСообщения.ОченьВажное);

	Если ДелатьСообщенияТранслитом Тогда
		Сообщение = Транслит(Сообщение);
	КонецЕсли;

	Сообщить(Строка(ТекущаяДата()) + " " + Сообщение, ТипСообщения);
КонецПроцедуры

Процедура Отладка(Знач Сообщение) Экспорт
	Если DebugLog Тогда
		СделатьСообщение(Сообщение);
	КонецЕсли;
КонецПроцедуры

Функция ДополнитьСлешВПуть(Знач Каталог)
	разделитель = "\";

	Если ЭтоLinux Тогда
		разделитель = "/";
	КонецЕсли;

	Если Найти(Прав(Каталог, 1), "\/") > 0 Тогда
		Каталог = Лев(Каталог,СтрДлина(Каталог)-1);
	КонецЕсли;

	Если Прав(Каталог, 1) <> разделитель Тогда
		Каталог = Каталог + разделитель;
	КонецЕсли;

	Возврат Каталог;

КонецФункции


//{Отчет Allure

Процедура ЗаписатьСтатусВШагИлиСценарий(ОбъектДляЗаписи,Статус)
	Если Статус = "Success" Тогда
		ОбъектДляЗаписи.status = "passed";
	ИначеЕсли Статус = "Pending" Тогда
		ОбъектДляЗаписи.status = "pending";
	ИначеЕсли Статус = "Failed" Тогда
		ОбъектДляЗаписи.status = "failed";
	ИначеЕсли Статус = "Skipped" Тогда
		ОбъектДляЗаписи.status = "skipped";
	Иначе
		ОбъектДляЗаписи.status = "skipped";
	КонецЕсли;


КонецПроцедуры

Процедура ДобавитьПрефиксAllureВСтроку(Стр)
	Стр = СтрЗаменить(Стр,"<test-suite-result","<ns2:test-suite");
	Стр = СтрЗаменить(Стр,"</test-suite-result>","</ns2:test-suite>");
	Стр = СтрЗаменить(Стр,"xmlns=""urn:model.allure.qatools.yandex.ru""","xmlns:ns2=""urn:model.allure.qatools.yandex.ru""");
КонецПроцедуры

Процедура ДобавитьМетку(Фабрика,СписокМеток,name,value, СписокПереопределяемый = Неопределено)
	Если СписокПереопределяемый <> Неопределено И ТипЗнч(СписокПереопределяемый) = Тип("СписокЗначений") Тогда
		Если СписокПереопределяемый.НайтиПоЗначению(name) <> Неопределено Тогда
			Возврат;
		КонецЕсли;
	КонецЕсли;

	Типlabel    = Фабрика.Тип("urn:model.allure.qatools.yandex.ru", "label");
	Метка       = Фабрика.Создать(Типlabel);
	Метка.name  = name;
	Метка.value = value;

	СписокМеток.label.Добавить(Метка);
КонецПроцедуры

Функция УбратьСимволыДляКорректногоОтчетаAllure(Знач Стр)
	Стр = СтрЗаменить(Стр,".","_");
	Возврат Стр;
КонецФункции

Функция ПолучитьПрефиксИмениСценария()
	Если ЗначениеЗаполнено(ИмяТекущейСборки) Тогда
		Возврат "(" + УбратьСимволыДляКорректногоОтчетаAllure(ИмяТекущейСборки) + ") ";
	КонецЕсли;

	Возврат "";

	//СисИнфо          = Новый СистемнаяИнформация;
	//ВерсияПриложения = СисИнфо.ВерсияПриложения;
	//
	//ВерсияПриложения = СтрЗаменить(ВерсияПриложения,".","-");
	//
	//ТипФорм = "OF";
	//Если ОтчетВРежимеУФ Тогда
	//	ТипФорм = "UF";
	//	Если ПараметрыОтчетаУФ.ЕстьПоддержкаАсинхронныхВызовов Тогда
	//		ТипФорм = "UF" + "_NoSync";
	//	КонецЕсли;
	//КонецЕсли;
	//
	//Возврат "(" + ВерсияПриложения + "_" + ТипФорм + ") ";
КонецФункции

Процедура ОбойтиДеревоДляОтчетаАллюр(Дерево,Фабрика,ТекущаяФича = Неопределено,СписокСценариев = Неопределено,СписокШагов = Неопределено)
	Для каждого СтрСтроки Из Дерево.Строки Цикл
		Если      СтрСтроки.Тип = "Фича" Тогда

			GUID             = Новый УникальныйИдентификатор();
			РеальноеИмяФайла = "" + GUID +"-testsuite.xml";
			ИмяФайлаXML      = ДополнитьСлешВПуть(КаталогOutputAllure) + РеальноеИмяФайла;

			Если ОтчетВРежимеУФ Тогда
				СтруткутаДляФайлаXML = Новый Структура;
				СтруткутаДляФайлаXML.Вставить("РеальноеИмяФайла",РеальноеИмяФайла);

				ИмяФайлаXML = ПолучитьИмяВременногоФайла("xml");
			КонецЕсли;

			ЗТ = Новый ЗаписьТекста(ИмяФайлаXML, КодировкаТекста.ANSI);
			ЗТ.Закрыть();

			ВременныйФайлXML = ПолучитьИмяВременногоФайла("xml");
			ЗаписьXML = Новый ЗаписьXML;

			ЗаписьXML.ОткрытьФайл(ВременныйФайлXML);
			ЗаписьXML.ЗаписатьОбъявлениеXML();

			ТипTestSuiteResult = Фабрика.Тип("urn:model.allure.qatools.yandex.ru", "test-suite-result");
			ТекущаяФича        = Фабрика.Создать(ТипTestSuiteResult);
			ТекущаяФича.name   = СтрСтроки.Имя;

			ТипTestCasesResult = Фабрика.Тип("urn:model.allure.qatools.yandex.ru", "test-cases-result");
			СписокСценариев    = Фабрика.Создать(ТипTestCasesResult);

			ОбойтиДеревоДляОтчетаАллюр(СтрСтроки,Фабрика,ТекущаяФича,СписокСценариев,СписокШагов);

			ТекущаяФича.test_cases = СписокСценариев;


			Типlabels   = Фабрика.Тип("urn:model.allure.qatools.yandex.ru", "labels");
			СписокМеток = Фабрика.Создать(Типlabels);

			ДобавитьМетку(Фабрика,СписокМеток,"feature",СтрСтроки.Имя);
			ДобавитьМетку(Фабрика,СписокМеток,"framework","vanessa-behavior");
			ДобавитьМетку(Фабрика,СписокМеток,"language","1С");


			ТекущаяФича.labels = СписокМеток;

			Фабрика.ЗаписатьXML(ЗаписьXML, ТекущаяФича);
			ЗаписьXML.Закрыть();


			//делаем запись без BOM и немного преобразуем строки xml
			ЗТ = Новый ЗаписьТекста(ИмяФайлаXML,,, Истина);
			Текст = Новый ЧтениеТекста;
			Текст.Открыть(ВременныйФайлXML,"UTF-8");

			Пока Истина Цикл
				Стр = Текст.ПрочитатьСтроку();
				Если Стр = Неопределено Тогда
					Прервать;
				КонецЕсли;
				ДобавитьПрефиксAllureВСтроку(Стр);

				ЗТ.ЗаписатьСтроку(Стр);
			КонецЦикла;
			ЗТ.Закрыть();
			Текст.Закрыть();


			Если ОтчетВРежимеУФ Тогда
				ДвоичныеДанные = Новый ДвоичныеДанные(ИмяФайлаXML);
				СтруткутаДляФайлаXML.Вставить("ФайлXMLДвоичныеДанные",ДвоичныеДанные);
				ПараметрыОтчетаУФ.МассивXMLОтчетаAllure.Добавить(СтруткутаДляФайлаXML);

				УдалитьФайлы(ИмяФайлаXML);
			Иначе
				СделатьСообщение("Файл отчета Allure-report (" + ИмяФайлаXML + ") записан.");
			КонецЕсли;


		ИначеЕсли (СтрСтроки.Тип = "Сценарий") или (СтрСтроки.Тип = "Пример") Тогда
			Если (СтрСтроки.ДопТип = "Контекст") Тогда
				//его не неадо добавлять в отчет, т.к. этот сценарий включается в каждый сценарий

			ИначеЕсли (СтрСтроки.ДопТип = "СтруктураСценария") или (СтрСтроки.Строки.Количество() = 0) Тогда
				//его не неадо добавлять в отчет, т.к. этот сценарий явно не выполняется
				ОбойтиДеревоДляОтчетаАллюр(СтрСтроки,Фабрика,ТекущаяФича,СписокСценариев,СписокШагов);
			Иначе

				РезультатПрохожденияТестовСценария = ПолучитьРезультатПрохожденияТестовСценария(СтрСтроки);

				Если РезультатПрохожденияТестовСценария = Неопределено Тогда
					Продолжить;
				КонецЕсли;

				ТипTestCaseResult = Фабрика.Тип("urn:model.allure.qatools.yandex.ru", "test-case-result");
				Сценарий          = Фабрика.Создать(ТипTestCaseResult);

				ПрефиксИмениСценария = "";
				Если ДобавлятьКИмениСценарияУсловияВыгрузки Тогда
					ПрефиксИмениСценария = ПолучитьПрефиксИмениСценария();
				КонецЕсли;

				Если СтрСтроки.Тип = "Пример" Тогда
					Сценарий.name     = ПрефиксИмениСценария + СтрСтроки.Родитель.Родитель.Имя + " №" + (СтрСтроки.Родитель.Строки.Индекс(СтрСтроки));
				Иначе
					Сценарий.name     = ПрефиксИмениСценария + СтрСтроки.Имя;
				КонецЕсли;

				Сценарий.start = РезультатПрохожденияТестовСценария.ВремяНачала;
				Сценарий.stop  = РезультатПрохожденияТестовСценария.ВремяОкончания;


				ТипSteps    = Фабрика.Тип("urn:model.allure.qatools.yandex.ru", "steps");
				СписокШагов = Фабрика.Создать(ТипSteps);



				Если СтрСтроки.ДопТип = "СтруктураСценария" Тогда
					ОбойтиДеревоДляОтчетаАллюр(СтрСтроки,Фабрика,ТекущаяФича,СписокСценариев,СписокШагов);
				Иначе
					Для каждого СтрРезультатПрохожденияТестовШагов Из РезультатПрохожденияТестовСценария.РезультатПрохожденияТестовШагов Цикл
						ТипStep   = Фабрика.Тип("urn:model.allure.qatools.yandex.ru", "step");
						Шаг       = Фабрика.Создать(ТипStep);
						Шаг.name  = СтрРезультатПрохожденияТестовШагов.Имя;
						Шаг.title = СтрРезультатПрохожденияТестовШагов.Имя;

						Если СтрРезультатПрохожденияТестовШагов.ВремяНачала <> Неопределено Тогда
							Шаг.start = СтрРезультатПрохожденияТестовШагов.ВремяНачала;
							Шаг.stop  = СтрРезультатПрохожденияТестовШагов.ВремяОкончания;
						КонецЕсли;

						ЗаписатьСтатусВШагИлиСценарий(Шаг,СтрРезультатПрохожденияТестовШагов.Статус);

						СписокШагов.step.Добавить(Шаг);
					КонецЦикла;
				КонецЕсли;




				ЗаписатьСтатусВШагИлиСценарий(Сценарий,СтрСтроки.Статус);
				Если (СтрСтроки.Статус = "Failed") или (СтрСтроки.Статус = "Pending") Тогда
					ТипFailure            = Фабрика.Тип("urn:model.allure.qatools.yandex.ru", "failure");
					ОбъектFailure         = Фабрика.Создать(ТипFailure);
					ОбъектFailure.message = РезультатПрохожденияТестовСценария.ОписаниеОшибки;

					Сценарий.failure = ОбъектFailure;
				КонецЕсли;
				Сценарий.steps = СписокШагов;


				Если РезультатПрохожденияТестовСценария.Свойство("МассивСкриншотов") Тогда
					//значит есть скриншоты

					Типattachments    = Фабрика.Тип("urn:model.allure.qatools.yandex.ru", "attachments");
					Списокattachments = Фабрика.Создать(Типattachments);

					Для каждого СтруктураСкриншот Из РезультатПрохожденияТестовСценария.МассивСкриншотов Цикл
						Типattachment  = Фабрика.Тип("urn:model.allure.qatools.yandex.ru", "attachment");
						attachment      = Фабрика.Создать(Типattachment);

						attachment.title  = "screenshot";
						attachment.source = СтруктураСкриншот.ИмяФайла;

						Списокattachments.attachment.Добавить(attachment);
					КонецЦикла;
					Сценарий.attachments = Списокattachments;
				КонецЕсли;


				Типlabels   = Фабрика.Тип("urn:model.allure.qatools.yandex.ru", "labels");
				СписокМеток = Фабрика.Создать(Типlabels);
				ДобавитьМетку(Фабрика,СписокМеток,"story",СтрСтроки.Имя);
				Сценарий.labels = СписокМеток;



				СписокСценариев.test_case.Добавить(Сценарий);
				//Сообщить(СтрСтроки.Имя);
			КонецЕсли;
		ИначеЕсли СтрСтроки.Тип = "Шаг" Тогда
			Если СтрСтроки.Родитель.ДопТип = "СтруктураСценария" Тогда
				//его не неадо добавлять в отчет, т.к. этот сценарий явно не выполняется
				ОбойтиДеревоДляОтчетаАллюр(СтрСтроки,Фабрика,ТекущаяФича,СписокСценариев,СписокШагов);
			Иначе
				//ТипStep   = Фабрика.Тип("urn:model.allure.qatools.yandex.ru", "step");
				//Шаг       = Фабрика.Создать(ТипStep);
				//Шаг.name  = СтрСтроки.Имя;
				//Шаг.title = СтрСтроки.Имя;
				//
				//Если СтрСтроки.ВремяНачала <> Неопределено Тогда
				//	Шаг.start = СтрСтроки.ВремяНачала;
				//	Шаг.stop  = СтрСтроки.ВремяОкончания;
				//КонецЕсли;
				//
				//ЗаписатьСтатусВШагИлиСценарий(Шаг,СтрСтроки.Статус);
				//СписокШагов.step.Добавить(Шаг);
			КонецЕсли;
		Иначе
			ОбойтиДеревоДляОтчетаАллюр(СтрСтроки,Фабрика,ТекущаяФича,СписокСценариев,СписокШагов);
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

Процедура СформироватьОтчетАллюр(СтруктураОФ = Неопределено) Экспорт
	Перем СтарыйКаталог, ИмяФайла;

	СтарыйКаталог = КаталогOutputAllure;

	ОтчетВРежимеУФ = Ложь;

	Если СтруктураОФ = Неопределено Тогда
		ИмяФайла     = КаталогИнструментов + "/vendor/allure-framework/allure.xsd";
	Иначе

		Аллюр2 = Плагин("Аллюр2Отчет");
		//СформироватьОтчетАллюр2(СтруктураОФ, ДеревоТестов, ИмяТекущейСборки);
		Аллюр2.СформироватьОтчетАллюр2(СтруктураОФ, ДеревоТестов, ИмяТекущейСборки, ДобавлятьКИмениСценарияУсловияВыгрузки);
		Возврат;

КонецПроцедуры


Процедура ПроверитьРавенствоТабличныхДокументовТолькоПоЗначениям(ТабДок1, ТабДок2, УчитыватьТолькоВидимыеКолонкиИлиДопСообщениеОшибки = Ложь, УчитыватьТолькоВидимыеСтрокиИлиДопСообщениеОшибки = Ложь, Знач ДопСообщениеОшибки = "",ДопПараметры = Неопределено) Экспорт

	УтвержденияПроверкаТаблиц = Плагин("УтвержденияПроверкаТаблиц");
	УтвержденияПроверкаТаблиц.ПроверитьРавенствоТабличныхДокументовТолькоПоЗначениям(ТабДок1, ТабДок2, УчитыватьТолькоВидимыеКолонкиИлиДопСообщениеОшибки, УчитыватьТолькоВидимыеСтрокиИлиДопСообщениеОшибки, ДопСообщениеОшибки, ДопПараметры);

КонецПроцедуры

Процедура ВызватьОшибкуПроверки(СообщениеОшибки)

	Префикс = "["+ СтатусыРезультатаТестирования.ОшибкаПроверки + "]";
	ВызватьИсключение Префикс + " " + СообщениеОшибки;

КонецПроцедуры

Процедура ПропуститьТест(Знач Сообщение = "") Экспорт

	Префикс = "[" + СтатусыРезультатаТестирования.ТестПропущен + "]";
	Если ПустаяСтрока(Сообщение) Тогда
		Сообщение = НСтр("ru = 'Тест пропущен'");
	КонецЕсли;
	ВызватьИсключение Префикс + " " + Сообщение;

КонецПроцедуры

//} МЕТОДЫ ДЛЯ ПРОВЕРКИ ЗНАЧЕНИЙ (assertions).


//портирован блок генерации данных из проекта xUnitFor1C (https://github.com/xDrivenDevelopment/xUnitFor1C)
//был взят релиз 3.0.0.3
// { Методы генерации тестовых данных

Функция СоздатьДанныеПоМакетам(ТестОбъект, ИменаМакетов) Экспорт
	Сериализатор = Плагин("СериализаторMXL");
	Возврат Сериализатор.СоздатьДанныеПоМакетам(ТестОбъект, ИменаМакетов);
КонецФункции

Функция СоздатьДанныеПоТабличномуДокументу(ТабличныйДокументИлиМассивТабличныхДокументов, РежимыЗагрузкиИлиИмяКолонкиЗамещения = Неопределено, ИмяКолонкиЗамещения = Неопределено) Экспорт
	Сериализатор = Плагин("СериализаторMXL");
	Возврат Сериализатор.СоздатьДанныеПоТабличномуДокументу(ТабличныйДокументИлиМассивТабличныхДокументов, РежимыЗагрузкиИлиИмяКолонкиЗамещения, ИмяКолонкиЗамещения);
КонецФункции

// удаляет созданные элементы (Справочники, Документы, Пользователи ИБ), регистры сведений не чистит - есть тесты
Функция УдалитьСозданныеДанные(Данные) Экспорт
	Сериализатор = Плагин("СериализаторMXL");
	Возврат Сериализатор.УдалитьСозданныеДанные(Данные);
КонецФункции

// }

//{ Чтение JSON файла

Функция ПолучитьИмяПараметра(ТаблицаЗначенийИзФайла,СтрокаИзФайла,СчетчикСтрок,ПозицияВСтроке)
	Стр = "";

	КолСимволов = СтрДлина(СтрокаИзФайла);
	Пока Истина Цикл
		ПозицияВСтроке = ПозицияВСтроке + 1;
		Если ПозицияВСтроке > КолСимволов Тогда
			Прервать;
		КонецЕсли;
		Символ = Сред(СтрокаИзФайла,ПозицияВСтроке,1);

		Если Символ = """" Тогда
			Прервать;
		КонецЕсли;

		Стр = Стр + Символ;
	КонецЦикла;

	Возврат Стр;
КонецФункции

Функция ПрочитатьСтруктуруИзJSON(ТаблицаЗначенийИзФайла, СчетчикСтрок, ПозицияВСтроке, Результат, ЧитатьВСоответствие)

	Если ЧитатьВСоответствие Тогда
		СтруктураДляЗаполнения = Новый Соответствие;
	Иначе
		СтруктураДляЗаполнения = Новый Структура;
	КонецЕсли;

	Пока Истина Цикл
		ПозицияВСтроке = 0;
		СчетчикСтрок = СчетчикСтрок + 1;
		Если СчетчикСтрок > (ТаблицаЗначенийИзФайла.Количество() - 1) Тогда
			Прервать;
		КонецЕсли;
		Стр = ТаблицаЗначенийИзФайла[СчетчикСтрок].Стр;
		Если Лев(Стр, 1) = "}" Тогда
			Прервать;
		КонецЕсли;
		ОбработатьСтроку(ТаблицаЗначенийИзФайла, ТаблицаЗначенийИзФайла[СчетчикСтрок].Стр, СчетчикСтрок, ПозицияВСтроке, Результат, СтруктураДляЗаполнения, ЧитатьВСоответствие);
	КонецЦикла;

	Возврат СтруктураДляЗаполнения;

КонецФункции

Функция ПрочитатьМассивИзJSON(ТаблицаЗначенийИзФайла, СчетчикСтрок, ПозицияВСтроке, Результат, ЧитатьВСоответствие)

	СтруктураДляЗаполнения = Новый Массив;

	Пока Истина Цикл
		ПозицияВСтроке = 0;
		СчетчикСтрок = СчетчикСтрок + 1;
		Если СчетчикСтрок > (ТаблицаЗначенийИзФайла.Количество() - 1) Тогда
			Прервать;
		КонецЕсли;

		Стр = ТаблицаЗначенийИзФайла[СчетчикСтрок].Стр;
		Если Лев(Стр, 1) = "]" Тогда
			Прервать;
		КонецЕсли;

		Если Прав(Стр, 1) = "," Тогда
			Стр = Лев(Стр, СтрДлина(Стр) - 1);
		КонецЕсли;

		Если Лев(Стр, 1) = "{" Тогда
			Значение = ПрочитатьСтруктуруИзJSON(ТаблицаЗначенийИзФайла, СчетчикСтрок, ПозицияВСтроке, Результат, ЧитатьВСоответствие);
			СтруктураДляЗаполнения.Добавить(Значение);
			Продолжить;
		КонецЕсли;

		Стр = УбратьЛишниеКавычки(Стр);
		СтруктураДляЗаполнения.Добавить(Стр);
	КонецЦикла;

	Возврат СтруктураДляЗаполнения;

КонецФункции

Функция ПолучитьЗначениеИзJSON(ТаблицаЗначенийИзФайла, СтрокаИзФайла, СчетчикСтрок, ПозицияВСтроке, Результат, ЧитатьВСоответствие)

	Значение = "";
	КолСимволов = СтрДлина(СтрокаИзФайла);

	// Пропускаем проблелы
	Пока Истина Цикл
		ПозицияВСтроке = ПозицияВСтроке + 1;
		Если ПозицияВСтроке > КолСимволов Тогда
			Прервать;
		КонецЕсли;
		Символ = Сред(СтрокаИзФайла, ПозицияВСтроке, 1);

		Если Символ = " " Тогда
			Продолжить;
		Иначе
			Прервать;
		КонецЕсли;
	КонецЦикла;

	// Сейчас мы на первом не пустом символе
	БылОдинСтроковыйСимвол = Ложь;
	ПозицияВСтроке = ПозицияВСтроке - 1;
	Пока Истина Цикл
		ПозицияВСтроке = ПозицияВСтроке + 1;
		Если ПозицияВСтроке > КолСимволов Тогда
			Прервать;
		КонецЕсли;
		Символ = Сред(СтрокаИзФайла, ПозицияВСтроке, 1);

		Если НЕ БылОдинСтроковыйСимвол Тогда
			Если Символ = "{" Тогда
				Значение = ПрочитатьСтруктуруИзJSON(ТаблицаЗначенийИзФайла, СчетчикСтрок, ПозицияВСтроке, Результат, ЧитатьВСоответствие);
				Прервать;
			ИначеЕсли Символ = "[" Тогда
				Если Сред(СтрокаИзФайла, ПозицияВСтроке+1, 1) = "]" Тогда
					//значит это пустой массив
					Значение = Новый Массив;
					Прервать;
				КонецЕсли;
				Значение = ПрочитатьМассивИзJSON(ТаблицаЗначенийИзФайла, СчетчикСтрок, ПозицияВСтроке, Результат, ЧитатьВСоответствие);
				Прервать;
			КонецЕсли;
		КонецЕсли;

		Если ПозицияВСтроке = КолСимволов Тогда // значит это последний символ в строке
			Если Символ = "," Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;

		Значение = Значение + Символ;

		БылОдинСтроковыйСимвол = Истина;

	КонецЦикла;

	Значение = УбратьЛишниеКавычки(Значение);

	Возврат Значение;

КонецФункции

Функция УбратьЛишниеКавычки(Знач Значение)

	Если (Лев(Значение, 1) = "'") И (Прав(Значение, 1) = "'") Тогда
		Значение = Сред(Значение, 2, СтрДлина(Значение) - 2);
	КонецЕсли;

	Если (Лев(Значение, 1) = """") И (Прав(Значение, 1) = """") Тогда
		Значение = Сред(Значение, 2, СтрДлина(Значение) - 2);
	КонецЕсли;

	Возврат Значение;

КонецФункции

Процедура ОбработатьСтроку(ТаблицаЗначенийИзФайла, СтрокаИзФайла, СчетчикСтрок, ПозицияВСтроке, Результат, СтруктураДляЗаполнения, ЧитатьВСоответствие)

	КолСимволов = СтрДлина(СтрокаИзФайла);
	Пока Истина Цикл
		ПозицияВСтроке = ПозицияВСтроке + 1;
		Если ПозицияВСтроке > КолСимволов Тогда
			Прервать;
		КонецЕсли;
		Символ = Сред(СтрокаИзФайла, ПозицияВСтроке, 1);

		Если Символ = "{" Тогда
			Если Результат = Неопределено Тогда
				Если ЧитатьВСоответствие Тогда
					Результат              = Новый Соответствие;
				Иначе
					Результат              = Новый Структура;
				КонецЕсли;
				СтруктураДляЗаполнения = Результат;
			КонецЕсли;
		ИначеЕсли Символ = "}" Тогда
		ИначеЕсли Символ = """" Тогда
			ТекИмя = ПолучитьИмяПараметра(ТаблицаЗначенийИзФайла, СтрокаИзФайла, СчетчикСтрок, ПозицияВСтроке);
		ИначеЕсли Символ = ":" Тогда
			Значение = ПолучитьЗначениеИзJSON(ТаблицаЗначенийИзФайла, СтрокаИзФайла, СчетчикСтрок, ПозицияВСтроке, Результат, ЧитатьВСоответствие);
			Если ТипЗнч(Значение) = Тип("Строка") Тогда
				Значение = СтрЗаменить(Значение, "'", "");
			КонецЕсли;
			СтруктураДляЗаполнения.Вставить(ТекИмя, Значение);
			Прервать;
		Иначе
			Сообщить("Ошибка чтения JSON! Неизвестный символ " + Символ);
			Возврат;
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

Функция ПрочитатьСтруктуруИзJSONФайла(ИмяФайлаVBParams, ПараметрыУФ = Неопределено) Экспорт

	Если ПараметрыУФ = Неопределено Тогда
		ИмяФайла = ИмяФайлаVBParams;
	Иначе
		VBParamsДвоичныеДанные = ПараметрыУФ.VBParamsДвоичныеДанные;
		ИмяФайла               = ПолучитьИмяВременногоФайла("json");
		VBParamsДвоичныеДанные.Записать(ИмяФайла);
	КонецЕсли;

	Возврат ПрочитатьКоллекциюИзJSONФайла(ИмяФайла);

КонецФункции

// }

Процедура ЗапретитьВыполнениеШагов() Экспорт
	ХостФорма = ПолучитьФорму("Форма");
	ХостФорма.ЗапретитьВыполнениеШаговФорма();
КонецПроцедуры

Процедура ПродолжитьВыполнениеШагов(ШагУпал = Ложь) Экспорт
	ХостФорма = ПолучитьФорму("Форма");
	ХостФорма.ПродолжитьВыполнениеШаговФорма(ШагУпал);
КонецПроцедуры

Процедура ОбойтиДеревоДляВнутреннегоФормата(Дерево, ТабличныйДокумент, Макет, Интервал, ПараметрыОтчетаУФ)

	Для каждого СтрСтроки Из Дерево.Строки Цикл
		Секция = Неопределено;
		Сценарий = Новый Структура("имя, name, start, stop, message, status");
		Если СтрСтроки.Тип = "Каталог" Тогда
			Секция = макет.ПолучитьОбласть("Заголовок");
		ИначеЕсли СтрСтроки.Тип = "Фича" Тогда
			Секция = макет.ПолучитьОбласть("Заголовок");
		ИначеЕсли СтрСтроки.Тип = "Шаг" Тогда
			Секция = макет.ПолучитьОбласть("Шаг");
		Иначе
			Секция = макет.ПолучитьОбласть("Заголовок");
		КонецЕсли;
		Если СтрСтроки.Тип = "Пример" Тогда
			Сценарий.name     = СтрСтроки.Родитель.Родитель.Имя + " №" + (СтрСтроки.Родитель.Строки.Индекс(СтрСтроки));
		Иначе
			Сценарий.name     = СтрСтроки.Имя;
		КонецЕсли;
		Сценарий.Имя = Интервал + СтрСтроки.Имя;

		Если СтрСтроки.Статус = "Failed" И НЕ СтрСтроки.Сценарий Тогда
			ИДВМассиве                         = ПараметрыОтчетаУФ.МассивИДСтрокиДерева.Найти(СтрСтроки.Родитель.ИДСтроки);
			Если ИДВМассиве <> Неопределено Тогда
				РезультатПрохожденияТестовСценария = ПараметрыОтчетаУФ.МассивРезультатПрохожденияТестовСценария[ИДВМассиве];
			КонецЕсли;
		КонецЕсли;

		Если РезультатПрохожденияТестовСценария <> Неопределено Тогда
			Сценарий.start = РезультатПрохожденияТестовСценария.ВремяНачала;
			Сценарий.stop  = РезультатПрохожденияТестовСценария.ВремяОкончания;
			Сценарий.message = РезультатПрохожденияТестовСценария.ОписаниеОшибки;
		КонецЕсли;

		Секция.Параметры.Заполнить(Сценарий);
		ТабличныйДокумент.Вывести(Секция);
		Если СтрСтроки.Статус = "Failed" И НЕ СтрСтроки.Сценарий Тогда
			Секция = макет.ПолучитьОбласть("Ошибка");
			Секция.Параметры.Заполнить(Сценарий);
			ТабличныйДокумент.Вывести(Секция);
		КонецЕсли;

		Если СтрСтроки.Строки.Количество() > 0 Тогда
			ТабличныйДокумент.НачатьАвтогруппировкуСтрок();
			ОбойтиДеревоДляВнутреннегоФормата(СтрСтроки, ТабличныйДокумент, Макет, Интервал + "   ", ПараметрыОтчетаУФ);
			ТабличныйДокумент.ЗакончитьАвтогруппировкуСтрок();
		КонецЕсли;
	КонецЦикла;


КонецПроцедуры

Функция ВывестиОтчетТестированияВоВнутреннемФормате(Дерево, ПараметрыОтчетаУФ) Экспорт


	ТабДок = Новый ТабличныйДокумент;
	макет = ПолучитьМакет("ОтчетТестирования");

	Секция = макет.ПолучитьОбласть("Заголовок");

	Интервал = "";
	ОбойтиДеревоДляВнутреннегоФормата(Дерево, ТабДок, Макет, Интервал + "   ", ПараметрыОтчетаУФ);

	ТабДок.ОтображатьСетку = Ложь;
	ТабДок.Защита = Ложь;
	ТабДок.ТолькоПросмотр = Ложь;
	ТабДок.ОтображатьЗаголовки = Ложь;

	Возврат ТабДок;

КонецФункции


Процедура Шаг(Стр) Экспорт
	ХостФорма = ПолучитьФорму("Форма");
	ХостФорма.ШагФорма(Стр);
КонецПроцедуры


Процедура СоздатьКолонкиДерева(Дерево) Экспорт
	Дерево.Колонки.Добавить("Имя");
	Дерево.Колонки.Добавить("Статус");
	Дерево.Колонки.Добавить("ПолныйПуть");
	//Дерево.Колонки.Добавить("Каталог");
	//Дерево.Колонки.Добавить("Фича");
	//Дерево.Колонки.Добавить("Сценарий");
	//Дерево.Колонки.Добавить("ЭтоScenarioOutline");
	//Дерево.Колонки.Добавить("ЭтоКонтекст");
	//Дерево.Колонки.Добавить("Примеры");
	Дерево.Колонки.Добавить("ИменованныеПараметры");
	//Дерево.Колонки.Добавить("Пример");
	//Дерево.Колонки.Добавить("Шаг");
	Дерево.Колонки.Добавить("ЗначенияПараметров");
	Дерево.Колонки.Добавить("Снипет");
	Дерево.Колонки.Добавить("АдресСнипета");
	Дерево.Колонки.Добавить("ЭтоЧужойСнипет");
	Дерево.Колонки.Добавить("СтрокаРеальнойПроцедуры");

	Дерево.Колонки.Добавить("РезультатПрохожденияТестовСценария");

	Дерево.Колонки.Добавить("ШагСПараметрамиВТаблице");
	Дерево.Колонки.Добавить("СтрокаПараметровШагаВВидеТаблицы");
	Дерево.Колонки.Добавить("ПараметрыТаблицы");
	Дерево.Колонки.Добавить("ИмяШагаБезКлючевогоСлова");
	Дерево.Колонки.Добавить("ШагСценарий");
	Дерево.Колонки.Добавить("МассивСценариевЗащитаОтЗацикливания");
	Дерево.Колонки.Добавить("ФичаИмеетСвоюEPF");
	//Дерево.Колонки.Добавить("Область");
	Дерево.Колонки.Добавить("МассивТегов");
	Дерево.Колонки.Добавить("НомерСтрокиВФиче");

	Если Дерево.Колонки.Найти("ТипКартинки") = Неопределено Тогда
		Дерево.Колонки.Добавить("ТипКартинки");
	КонецЕсли;

	Дерево.Колонки.Добавить("ЗначениеОтступа",Новый ОписаниеТипов("Число"));
	Дерево.Колонки.Добавить("Тип",Новый ОписаниеТипов("Строка"));
	Дерево.Колонки.Добавить("ДопТип",Новый ОписаниеТипов("Строка"));
	Дерево.Колонки.Добавить("ДополнительныеДанные");


	//Дерево.Колонки.Добавить("ВремяНачала");
	//Дерево.Колонки.Добавить("ВремяОкончания");
	//Дерево.Колонки.Добавить("ОписаниеОшибки");

КонецПроцедуры

Процедура ДобавитьШагВМассивТестов(МассивТестов,Снипет,ИмяПроцедуры,ПредставлениеТеста = Неопределено,ОписаниеШага = Неопределено,ТипШагаДляОписания = Неопределено,ТипШагаВДереве = Неопределено) Экспорт
	Структура = Новый Структура;

	Структура.Вставить("Снипет",Снипет);
	Структура.Вставить("ИмяПроцедуры",ИмяПроцедуры);
	Структура.Вставить("ПредставлениеТеста",ПредставлениеТеста);
	Структура.Вставить("ОписаниеШага",ОписаниеШага);
	Структура.Вставить("ТипШага",ТипШагаДляОписания);
	Структура.Вставить("ТипШагаВДереве",ТипШагаВДереве);
	Структура.Вставить("Транзакция",Неопределено);
	МассивТестов.Добавить(Структура);
КонецПроцедуры

Функция ПрочитатьКоллекциюИзJSONФайла(ИмяФайла, ЧитатьВСоответствие = Ложь)
	Перем Результат;

	Результат              = Неопределено;
	СтруктураДляЗаполнения = Неопределено;
	ТекЗначение            = Неопределено;

	ЕстьЧтениеJSON = Ложь;
	Попытка
		ЧтениеJSON = Вычислить("Новый ЧтениеJSON");
	    ЕстьЧтениеJSON = Истина;
	Исключение
	КонецПопытки;

	Если ЕстьЧтениеJSON Тогда
		ЧтениеJSON = Вычислить("Новый ЧтениеJSON");
		ЧтениеJSON.ОткрытьФайл(ИмяФайла);
		Выполнить("Результат = ПрочитатьJSON(ЧтениеJSON, ЧитатьВСоответствие)");
	Иначе

		ТаблицаЗначенийИзФайла = Новый ТаблицаЗначений;
		ТаблицаЗначенийИзФайла.Колонки.Добавить("Стр");

		Текст = Новый ЧтениеТекста;
		Текст.Открыть(ИмяФайла, "UTF-8");

		ТекИмя = Неопределено;
		Пока Истина Цикл
			Стр = Текст.ПрочитатьСтроку();
			Если Стр = Неопределено Тогда
				Прервать;
			КонецЕсли;

			Стр = СокрЛП(Стр);
			Если Стр = "" Тогда
				Продолжить;
			КонецЕсли;

			Стр = СтрЗаменить(Стр, "\""", """");
			Стр = СтрЗаменить(Стр, "\\", "\");

			СтрТаблицаЗначенийИзФайла     = ТаблицаЗначенийИзФайла.Добавить();
			СтрТаблицаЗначенийИзФайла.Стр = Стр;
		КонецЦикла;

		Текст.Закрыть();

		СчетчикСтрок = -1;
		Пока Истина Цикл
			СчетчикСтрок = СчетчикСтрок + 1;
			Если СчетчикСтрок > (ТаблицаЗначенийИзФайла.Количество() - 1) Тогда
				Прервать;
			КонецЕсли;

			ПозицияВСтроке = 0;
			ОбработатьСтроку(ТаблицаЗначенийИзФайла, ТаблицаЗначенийИзФайла[СчетчикСтрок].Стр, СчетчикСтрок, ПозицияВСтроке, Результат, СтруктураДляЗаполнения, ЧитатьВСоответствие);
		КонецЦикла;
	КонецЕсли;

	Возврат Результат;

КонецФункции

// Функция - Прочитать соответствие из JSON-файла
// Предназначена для чтения данных из JSON-файла в коллекцию типа Соответствие
//
// Параметры:
//  ДанныеJSON	 - ДвоичныеДанные	 - двоичные данные файла JSON;
//  			 - Структура		 - структура параметров VB со свойством VBParamsДвоичныеДанные.
//  								   Для совместимости со старым методом;
//  			 - Строка			 - путь в файлу JSON
//
// Возвращаемое значение:
//  Соответствие - коллекция значений из JSON-файла
//
Функция ПрочитатьСоответствиеИзJSONФайла(ДанныеJSON) Экспорт

		// Если параметром переданые двоичные данные, то записываем их во временный файл
	Если ТипЗнч(ДанныеJSON) = Тип("ДвоичныеДанные") Тогда
		ИмяФайла               = ПолучитьИмяВременногоФайла("json");
		ДанныеJSON.Записать(ИмяФайла);
	// Если параметром передана структура с параметрами VB,
	// то берем двоичные данные из свойства "VBParamsДвоичныеДанные"
	ИначеЕсли ТипЗнч(ДанныеJSON) = Тип("Структура") Тогда
		JSONДвоичныеДанные = ДанныеJSON.VBParamsДвоичныеДанные;
		ИмяФайла               = ПолучитьИмяВременногоФайла("json");
		JSONДвоичныеДанные.Записать(ИмяФайла);
	// Если параметром передана строка, то считаем, что это путь к файлу JSON
	ИначеЕсли ТипЗнч(ДанныеJSON) = Тип("Строка") Тогда
		ИмяФайла = ДанныеJSON;
	КонецЕсли;

	Возврат ПрочитатьКоллекциюИзJSONФайла(ИмяФайла, Истина);

КонецФункции


Процедура УстановитьРезультатУсловия(Результат) Экспорт
	РезультатУсловия = Результат;
КонецПроцедуры


СтатусыРезультатаТестирования = Новый Структура;
СтатусыРезультатаТестирования.Вставить("ОшибкаПроверки", "Failed");
СтатусыРезультатаТестирования.Вставить("НеизвестнаяОшибка", "Broken");
СтатусыРезультатаТестирования.Вставить("ТестПропущен", "Pending");
СтатусыРезультатаТестирования = Новый ФиксированнаяСтруктура(СтатусыРезультатаТестирования);

РезультатыСравненияТаблиц = Новый Структура;
РезультатыСравненияТаблиц.Вставить("ТаблицыСовпадают", 0);
РезультатыСравненияТаблиц.Вставить("НеСовпадаютЗначенияВЯчейкеТаблицы", 1);
РезультатыСравненияТаблиц.Вставить("РазноеКоличествоСтрок", 2);
РезультатыСравненияТаблиц.Вставить("РазличаютсяКолонки", 3);
РезультатыСравненияТаблиц = Новый ФиксированнаяСтруктура(РезультатыСравненияТаблиц);

СисИнфо = Новый СистемнаяИнформация;
ЭтоLinux = (Найти(Строка(СисИнфо.ТипПлатформы), "Linux") > 0);

ТипыПлагинов = ТипыПлагинов();
